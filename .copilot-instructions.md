# AI Copilot Instructions for MCP Azure Deployment Service

This file contains comprehensive guidelines for AI-assisted development in this project. Follow these rules consistently for code generation, documentation, testing, and MCP server implementation.

## Code Generation Rules

### TypeScript/JavaScript Development

- **Use TypeScript with strict type checking**
  - Enable `strict: true` in `tsconfig.json`
  - Always use TypeScript type hints and interfaces
  - Avoid `any` type - use proper type definitions

- **Error Handling**
  - Implement comprehensive error handling with try/catch blocks
  - Always handle async operations with proper error catching
  - Use structured error objects with meaningful messages

- **Clean Code Principles**
  - Follow SOLID principles (Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion)
  - Apply DRY (Don't Repeat Yourself) - extract common functionality
  - Keep it KISS (Keep It Simple, Stupid) - prefer simple, readable solutions

- **Function Documentation**
  - Add JSDoc comments for all public functions
  - Include parameter types, return types, and examples
  - Document thrown exceptions

- **Async Programming**
  - Use async/await instead of callbacks or raw Promises
  - Always handle Promise rejections
  - Prefer functional programming patterns over imperative

- **Variable Naming**
  - Use descriptive variable names (no single letters except loop counters)
  - Use camelCase for variables and functions
  - Use PascalCase for classes and interfaces
  - Use UPPER_SNAKE_CASE for constants

### Python Development

- **Type Hints**
  - Always use Python type hints for function parameters and return values
  - Import types from `typing` module when needed
  - Use `Optional` for nullable values

- **Documentation**
  - Add docstrings for all public functions following Google or NumPy style
  - Include parameter descriptions, return value descriptions, and exceptions

- **Error Handling**
  - Use try/except blocks with specific exception types
  - Include meaningful error messages
  - Log errors appropriately

## Documentation Requirements

### Auto-Generated Documentation

- **README.md Sections**: Generate and maintain the following sections:
  - Installation instructions with prerequisites
  - Usage examples with code snippets
  - API documentation with endpoint descriptions
  - Configuration examples
  - Troubleshooting guide

- **CHANGELOG.md**: Update with each significant change
  - Follow semantic versioning
  - Group changes by type: Added, Changed, Deprecated, Removed, Fixed, Security
  - Include date and version number

- **Inline Comments**: Add comments only for complex logic
  - Explain the "why", not the "what"
  - Keep comments concise and relevant
  - Update comments when code changes

- **Environment Variables**: Document all environment variables in `.env.example`
  - Include descriptions and example values
  - Mark required vs optional variables
  - Group related variables together

## Testing Standards

### Test Coverage and Quality

- **Generate unit tests** for every function
- **Aim for 90%+ code coverage**
- **Test frameworks**:
  - Use Jest for Node.js/TypeScript projects
  - Use pytest for Python projects

### Test Categories

- **Unit Tests**: Test individual functions in isolation
- **Integration Tests**: Test component interactions
- **Edge Cases**: Include boundary conditions and error scenarios
- **Error Scenarios**: Test exception handling and error paths

### Mocking Strategy

- **Mock external dependencies**: APIs, databases, file system
- **Mock stdio operations** for integration tests
- **Test all JSON-RPC request/response flows**
- Use dependency injection to make mocking easier

### Test Structure

```typescript
// Jest example
describe('ComponentName', () => {
  beforeEach(() => {
    // Setup
  });

  it('should handle normal case', () => {
    // Arrange, Act, Assert
  });

  it('should handle error case', () => {
    // Test error scenarios
  });
});
```

## Code Quality Tools

### Linting and Formatting

- **ESLint** (Node.js/TypeScript):
  - Configure with TypeScript-specific rules
  - Include accessibility and security rules
  - Set up extends: `@typescript-eslint/recommended`

- **Ruff** (Python):
  - Configure for fast linting and formatting
  - Include import sorting and code organization
  - Set line length to 88 characters

- **Prettier**: Configure for consistent formatting
  - Set up for TypeScript, JavaScript, JSON, Markdown
  - Configure line length, tab width, and quote style
  - Integrate with IDE and CI/CD

### Git Hooks

- **Pre-commit hooks with Husky**:
  - Run linting and formatting checks
  - Execute test suites
  - Validate commit message format
  - Check for secrets and sensitive data

- **Editor Configuration**:
  - Include `.editorconfig` for team consistency
  - Set charset, indent style, and line endings
  - Configure for multiple file types

## MCP Server Requirements

### Core Architecture

- **Dynamic Tool Registration**:
  ```typescript
  interface ToolHandler {
    name: string;
    description: string;
    inputSchema: JSONSchema;
    handler: (params: any) => Promise<any>;
  }
  
  registerTool(handler: ToolHandler): void;
  ```

- **JSON-RPC Communication**:
  - Parse JSON-RPC requests from stdin
  - Validate request format and required fields
  - Handle method routing dynamically

### Tool Execution

- **Parameter Validation**:
  - Validate against JSON Schema before execution
  - Provide clear validation error messages
  - Sanitize input parameters

- **Response Formatting**:
  ```typescript
  interface JSONRPCResponse {
    jsonrpc: "2.0";
    id: string | number | null;
    result?: any;
    error?: {
      code: number;
      message: string;
      data?: any;
    };
  }
  ```

### Error Handling

- **Structured Error Messages**:
  - Use standard JSON-RPC error codes
  - Include helpful error descriptions
  - Provide troubleshooting hints when possible

- **Graceful Degradation**:
  - Continue operation when individual tools fail
  - Log errors without breaking the server
  - Provide fallback responses when appropriate

### Logging and Debugging

- **stderr Logging**:
  - Log all operations to stderr for debugging
  - Use structured logging (JSON format preferred)
  - Include timestamps and operation context
  - Separate debug, info, warn, and error levels

- **Performance Monitoring**:
  - Track tool execution times
  - Monitor memory usage
  - Log request/response sizes

## Example Code Templates

### MCP Tool Handler Template

```typescript
/**
 * Azure resource deployment tool
 * @param params - Deployment parameters
 * @returns Deployment result with status and details
 */
async function deployAzureResource(params: {
  resourceType: string;
  configuration: Record<string, any>;
  subscriptionId: string;
}): Promise<{
  success: boolean;
  resourceId?: string;
  error?: string;
}> {
  try {
    // Validate parameters
    validateDeploymentParams(params);
    
    // Execute deployment
    const result = await azureClient.deploy(params);
    
    return {
      success: true,
      resourceId: result.id
    };
  } catch (error) {
    console.error('Deployment failed:', error);
    return {
      success: false,
      error: error.message
    };
  }
}
```

### Error Handling Pattern

```typescript
class MCPError extends Error {
  constructor(
    public code: number,
    message: string,
    public data?: any
  ) {
    super(message);
    this.name = 'MCPError';
  }
}

// Usage
throw new MCPError(-32602, 'Invalid parameters', { 
  field: 'subscriptionId', 
  reason: 'required but not provided' 
});
```

## Commit Message Format

Follow conventional commits format:

```
type(scope): description

[optional body]

[optional footer]
```

Types: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`

---

**Note**: These instructions should be followed consistently across all AI-generated code in this project. Update this file when project requirements change.